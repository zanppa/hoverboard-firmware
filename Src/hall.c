// Interrupt-driven hall-sensor position detection

/*
Copyright (C) 2019 Lauri Peltonen

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include "defines.h"
#include "config.h"
#include "math.h"
#include "hall.h"


extern volatile motor_state_t motor_state[2];

const uint16_t speed_to_svm = ANGLE_60DEG * HALL_TIMER_FREQ / (2*PWM_FREQ);  // Speed timer to modulator time scale



// Array to convert HALL sensor readings (order CBA, MSB first) to sector number
// Note that index 0 and 7 are "guards" and should never happen when sensors work properly
//static const uint8_t hall_to_sector[8] = { 0, 5, 1, 0, 3, 4, 2, 0 };
#if defined(HALL_GBYGBY)
static const uint8_t hall_to_sector[8] = { 0, 2, 0, 1, 4, 3, 5, 0 };
#elif defined(HALL_GBYBGY)
static const uint8_t hall_to_sector[8] = { 0, 2, 4, 3, 0, 1, 5, 0 };
#endif

// HALL mapping (original sector order)
// When board wire colors and motor wire colors match
//          Phases          HALLs
//  Sector  U/G V/B W/Y     G/2 B/1 Y/0     Bin Dec
//  0       1   0   0       0   1   0       010 2
//  1       1   1   0       0   1   1       011 3
//  2       0   1   0       0   0   1       001 1
//  3       0   1   1       1   0   1       101 5
//  4       0   0   1       1   0   0       100 4
//  5       1   0   1       1   1   0       110 6

// When board side has green and blue wires switched
//          Phases          HALLs
//  Sector  U/G V/B W/Y     G/2 B/1 Y/0     Bin Dec
//  0       1   0   0       1   0   0       100 4
//  1       1   1   0       1   0   1       101 5
//  2       0   1   0       0   0   1       001 1
//  3       0   1   1       0   1   1       011 3
//  4       0   0   1       0   1   0       010 2
//  5       1   0   1       1   1   0       110 6


// Read left hall sensors and return corresponding sector
uint8_t read_left_hall(void) {
  uint8_t sector;
  sector =  (LEFT_HALL_PORT->IDR >> LEFT_HALL_LSB_PIN) & 0b111;
  sector = hall_to_sector[sector];
  return sector;
}

// Read right hall sensors and return corresponding sector
uint8_t read_right_hall(void) {
  uint8_t sector;
  sector =  (RIGHT_HALL_PORT->IDR >> RIGHT_HALL_LSB_PIN) & 0b111;
  sector = hall_to_sector[sector];
  return sector;
}


// Setup HALL sensor timers and interrupts
void hall_setup(void)
{

  TIM_HandleTypeDef timer_left, timer_right;

  // Initialize one-pulse timers for speed calculation
  __HAL_RCC_TIM4_CLK_ENABLE();
  timer_left.Instance = TIM4;
  timer_left.Init.Prescaler         = 64000000 / 2 / HALL_TIMER_FREQ;
  timer_left.Init.CounterMode       = TIM_COUNTERMODE_UP;
  timer_left.Init.Period            = 0x7FFF;
  timer_left.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;
  timer_left.Init.RepetitionCounter = 0;
  timer_left.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  HAL_TIM_OnePulse_Init(&timer_left, TIM_OPMODE_SINGLE);

  // Enable update interrupt
  TIM4->DIER |= TIM_DIER_UIE;
  TIM4->CR1 &= ~(TIM_CR1_URS | TIM_CR1_UDIS); // Enable update events


  __HAL_RCC_TIM5_CLK_ENABLE();
  timer_right.Instance = TIM5;
  timer_right.Init.Prescaler         = 64000000 / 2 / HALL_TIMER_FREQ;
  timer_right.Init.CounterMode       = TIM_COUNTERMODE_UP;
  timer_right.Init.Period            = 0x7FFF;
  timer_right.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;
  timer_right.Init.RepetitionCounter = 0;
  timer_right.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  HAL_TIM_OnePulse_Init(&timer_right, TIM_OPMODE_SINGLE);
  //HAL_TIM_OnePulse_Start(&timer_right);

  // Enable update interrupt
  TIM5->DIER |= TIM_DIER_UIE;
  TIM5->CR1 &= ~(TIM_CR1_URS | TIM_CR1_UDIS); // Enable update events

  // Lower priority than modulator or current measurement
  // TODO: Make these #defines?
  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 7, 0);
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 7, 0);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
}


// Interrupt handler for left motor hall sensors
void EXTI9_5_IRQHandler(void)
{
  int16_t new_count;
  uint8_t new_sector, prev_sector;
  int16_t speed;
  uint16_t angle;

  // Verify that interrupt was generated by HALL sensor pins
  if(EXTI->PR & (0b111 << LEFT_HALL_LSB_PIN)) {
    EXTI->PR |= (0b111 << LEFT_HALL_LSB_PIN);  // Clear
  } else {
    return;
  }

  // Read the speed timer
  new_count = TIM4->CNT;
  if(!new_count) new_count = 0x7FFF;

  // Reset and re-trigger the counter
  TIM4->CNT = 0;
  TIM4->CR1 |= TIM_CR1_CEN;

  // Read and update the sector
  new_sector = read_left_hall();
  prev_sector = motor_state[STATE_LEFT].act.sector;

  // Determine rotor position
  angle = new_sector * ANGLE_60DEG - ANGLE_30DEG;  // Edge of a sector

  // Determine the rotation speed
  speed = speed_to_svm / new_count;
  if(new_sector != ((prev_sector + 1) % 6)) {
    speed = -speed;
    new_count = -new_count;
    angle += ANGLE_60DEG;
  }


  // Update motor control & state variables
  __disable_irq();
  motor_state[STATE_LEFT].act.sector = new_sector;
  motor_state[STATE_LEFT].act.period = new_count;
  motor_state[STATE_LEFT].ctrl.angle_min = angle;
  motor_state[STATE_LEFT].ctrl.angle_max = angle + ANGLE_60DEG;

#ifdef FOC_HALL_UPDATE
  motor_state[STATE_LEFT].act.angle = angle;
  motor_state[STATE_LEFT].ctrl.speed = speed;
#endif
  __enable_irq();
}

// Interrupt handler for right motor hall sensors
// TODO: Check which side this is
void EXTI15_10_IRQHandler(void)
{
  int16_t new_count;
  uint8_t new_sector, prev_sector;
  int16_t speed;
  uint16_t angle;

  // Verify that interrupt was generated by HALL sensor pins
  if(EXTI->PR & (0b111 << RIGHT_HALL_LSB_PIN)) {
    EXTI->PR |= (0b111 << RIGHT_HALL_LSB_PIN);  // Clear
  } else {
    return;
  }

  // Read the speed timer
  new_count = TIM5->CNT;
  if(!new_count) new_count = 0x7FFF;

  // Reset and re-trigger the counter
  TIM5->CNT = 0;
  TIM5->CR1 |= TIM_CR1_CEN;

  // Read and update the sector
  new_sector = read_right_hall();
  prev_sector = motor_state[STATE_RIGHT].act.sector;

  // Determine rotor position
  angle = new_sector * ANGLE_60DEG - ANGLE_30DEG;  // Edge of a sector

  // Determine the rotation speed
  speed = speed_to_svm / new_count;
  if(new_sector != ((prev_sector + 1) % 6)) {
    speed = -speed;
    new_count = -new_count;
    angle += ANGLE_60DEG;
  }

  // Update motor control & state variables
  __disable_irq();
  motor_state[STATE_RIGHT].act.sector = new_sector;
  motor_state[STATE_RIGHT].act.period = new_count;
  motor_state[STATE_RIGHT].ctrl.angle_min = angle;
  motor_state[STATE_RIGHT].ctrl.angle_max = angle + ANGLE_60DEG;

#ifdef FOC_HALL_UPDATE
  motor_state[STATE_RIGHT].act.angle = angle;
  motor_state[STATE_RIGHT].ctrl.speed = speed;
#endif
  __enable_irq();
}


// Left motor timer update (overflow) interrupt
void TIM4_IRQHandler(void)
{
  TIM4->SR = 0;
  // TODO: Do we need to clear CEN or is it done automatically even with interrupt in one-pulse mode?

#ifdef FOC_HALL_UPDATE
  // Set motor speed to zero
  motor_state[STATE_LEFT].ctrl.speed = 0;
  motor_state[STATE_LEFT].act.speed = 0;
#endif
}

// Right motor timer update (overflow) interrupt
void TIM5_IRQHandler(void)
{
  TIM5->SR = 0;
  // TODO: Do we need to clear CEN or is it done automatically even with interrupt in one-pulse mode?

#ifdef FOC_HALL_UPDATE
  // Set motor speed to zero
  motor_state[STATE_RIGHT].ctrl.speed = 0;
  motor_state[STATE_RIGHT].act.speed = 0;
#endif
}
